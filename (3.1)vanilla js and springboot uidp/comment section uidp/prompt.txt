

Im using springboot app with js in the frontend that implements a minimalistic comment section. 
can you the exact same thing but using react ? (just give me the code I know how to run it)


//index.html 
<!DOCTYPE html>
<html>
	<head>
		<!--<link rel="stylesheet" type="text/css" href="style.css">-->
                <title>Vanilla JavaScript Example</title>
	</head>
	<body>
		
		<p>aasdfasdfasdfasdfasdf</p>
		<div id="comments-container">
			<form id="add-comment-form">
			  <textarea id="comment-text"></textarea>
			  <button type="submit">Submit</button>
			</form>
			<ul id="comments-list">
			  <!-- comments will be added here dynamically -->
			</ul>
		</div>

		<script src="main.js"></script>
	</body>
</html>


//main.js 
const commentsList = document.getElementById('comments-list'); // Define commentsList variable
const responseDiv = document.getElementById('response');


const addCommentForm = document.getElementById("add-comment-form");
addCommentForm.addEventListener("submit", function(event) {
  event.preventDefault();
  const commentText = document.getElementById("comment-text").value;
  if (!commentText) {
    return;
  }
  console.log(commentText);
  document.getElementById("comment-text").value = ""; // Clear the input field
  addComment(commentText);
  
});

//this works 
const loadComments = () => {
	//const commentsList = document.getElementById('comments-list');
	//here the data is the comments 
	fetch('/message')
		.then(response => response.json())
		.then(data => {
			
			commentsList.innerHTML = ""; // Clear existing data
			data.forEach(comment => {
				const newComment = document.createElement("li");
				newComment.innerHTML = comment.message;
				commentsList.appendChild(newComment);
			});

		})
		.catch(error => {
			console.error('Error:', error);
		});
};

loadComments();  //if you use it here it will not run again after a form post 


function addComment(comment) {
  fetch("/comments", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      message: comment
    })
  })
    .then(response => {
      if (response.ok) {
        return response.json();
      }
      throw new Error("Error adding comment.");
    })
    .then(comment => {
      const newComment = document.createElement("li");
      newComment.innerHTML = comment.message;
      commentsList.appendChild(newComment);
      document.getElementById("comment-text").value = "";
      console.log("trying to load new comment in li" + comment); 
      loadComments(); // reaload list after successfully sending comment to db
    })
    .catch(error => {
      console.error("Error adding comment:", error);
    });
}








//MyController.java
package com.example.demo; 

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


@Controller
@RequestMapping("/")
public class MyController {
	
	@Autowired // inject commentService , you could also use constructor injection , they are equivalent
	private CommentService commentService;  
    
    //it will look for the html in either the template or static so dont worry aabout it 
    @GetMapping("/")
    public String loadIndexPage() {
        return "index.html";   	
    }

    //this works 
    @GetMapping("/message")
    public ResponseEntity<List<Comment>> getMessage() {
        List<Comment> comments = commentService.getAllComments();
        return ResponseEntity.ok(comments);
    }
    
    @PostMapping("/comments")
    public ResponseEntity<Comment> addComment(@RequestBody Comment comment) {
    	System.out.println(",,,,,,,,,,,,,,,posted with " + comment + ",,,,,,,,,,,,,,,,,,,,,");
        comment.setMessage(comment.getMessage());
        Comment savedComment = commentService.addComment(comment);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedComment);
    }
    
  

    
}












